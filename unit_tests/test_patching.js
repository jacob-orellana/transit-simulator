QUnit.module('patching.js');
/* globals QUnit Vertex UndirectedEdge UndirectedGraph City Route Bus Patch */
/* eslint-disable no-magic-numbers, no-underscore-dangle */

QUnit.test('do not start a patch from a vertex not on the route', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  const city = new City(graph, graph);
  const route = new Route(city, a, b);
  const patch = new Patch(graph, route);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
});

QUnit.test('do not start a patch from a vertex not on the core of the route', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(c, new UndirectedEdge(1), d);
  graph.addEdge(a, new UndirectedEdge(1), d);
  const city = new City(graph, graph);
  const route = new Route(city, a, d);
  route.patch(a, b, c, d);
  const x = new Bus(route.getArc(a)); // eslint-disable-line no-unused-vars
  route.patch(a, d);
  const patch = new Patch(graph, route);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
});

QUnit.test('patch a route by giving individual edges', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  const city = new City(graph, graph);
  const route = new Route(city, a, b);
  const patch = new Patch(graph, route);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, [b, c]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [b, c, a]);
  assert.deepEqual(patch.complete, true);
});

QUnit.test('patch a route by pathfinding', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  graph.addEdge(b, new UndirectedEdge(1), d);
  graph.addEdge(c, new UndirectedEdge(1), d);
  const city = new City(graph, graph);
  const route = new Route(city, a, b);
  const patch = new Patch(graph, route);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [b, d]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [b, d, c, a]);
  assert.deepEqual(patch.complete, true);
});

QUnit.test('avoid the route when patching a route by pathfinding', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const e = new Vertex('e');
  const f = new Vertex('f');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addVertex(e);
  graph.addVertex(f);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(c, new UndirectedEdge(1), d);
  graph.addEdge(d, new UndirectedEdge(1), a);
  graph.addEdge(a, new UndirectedEdge(1), e);
  graph.addEdge(e, new UndirectedEdge(1), f);
  graph.addEdge(f, new UndirectedEdge(1), c);
  const city = new City(graph, graph);
  const route = new Route(city, a, d);
  route.patch(a, b, c, d);
  const patch = new Patch(graph, route);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [a]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, [a, e, f, c]);
  assert.deepEqual(patch.complete, true);
});

QUnit.test('do not extend a route\'s patch by backtracking', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  graph.addEdge(c, new UndirectedEdge(1), d);
  const city = new City(graph, graph);
  const route = new Route(city, a, b);
  const patch = new Patch(graph, route);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [b, c, d]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [b, c, d]);
  assert.deepEqual(patch.complete, false);
});

QUnit.test('retract a route\'s patch', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  graph.addEdge(c, new UndirectedEdge(1), d);
  const city = new City(graph, graph);
  const route = new Route(city, a, b);
  const patch = new Patch(graph, route);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [b, c, d]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, [b, c]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [b, c, a]);
  assert.deepEqual(patch.complete, true);
});

QUnit.test('do not retract a route\'s patch on a repeated edit', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  graph.addEdge(c, new UndirectedEdge(1), d);
  const city = new City(graph, graph);
  const route = new Route(city, a, b);
  const patch = new Patch(graph, route);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [b, c, d]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [b, c, d]);
  assert.deepEqual(patch.complete, false);
});

QUnit.test('cancel a route\'s patch on a repeated edit of its start', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  const city = new City(graph, graph);
  const route = new Route(city, a, b);
  const patch = new Patch(graph, route);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, [b, c]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
});

QUnit.test('do not complete a patch with a vertex not on the core of the route', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(c, new UndirectedEdge(1), d);
  graph.addEdge(a, new UndirectedEdge(1), d);
  const city = new City(graph, graph);
  const route = new Route(city, a, d);
  route.patch(a, b, c, d);
  const x = new Bus(route.getArc(a)); // eslint-disable-line no-unused-vars
  route.patch(a, d);
  const patch = new Patch(graph, route);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [a]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [a, b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, [a, b, c]);
  assert.deepEqual(patch.complete, false);
});

QUnit.test('start a route-creating patch from anywhere', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  const patch = new Patch(graph, undefined);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, [c]);
  assert.deepEqual(patch.complete, false);
});

QUnit.test('create a degenerate route by giving individual edges', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addEdge(a, new UndirectedEdge(1), b);
  const patch = new Patch(graph, undefined);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [a]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [a, b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [a, b, a]);
  assert.deepEqual(patch.complete, true);
});

QUnit.test('create a simple route by giving individual edges', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  const patch = new Patch(graph, undefined);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, [b, c]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [b, c, a]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b, c, a, b]);
  assert.deepEqual(patch.complete, true);
});

QUnit.test('create a route by pathfinding', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  graph.addEdge(b, new UndirectedEdge(1), d);
  graph.addEdge(c, new UndirectedEdge(1), d);
  const patch = new Patch(graph, undefined);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [b, d]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [b, d, c, a]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b, d, c, a, b]);
  assert.deepEqual(patch.complete, true);
});

QUnit.test('avoid the patch when extending a route-creating patch by pathfinding', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const e = new Vertex('e');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addVertex(e);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), d);
  graph.addEdge(d, new UndirectedEdge(1), e);
  graph.addEdge(e, new UndirectedEdge(1), c);
  const patch = new Patch(graph, undefined);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, [c]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(e);
  assert.deepEqual(patch.vertices, [c, e]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [c, e, d]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, [c, e, d, a, b, c]);
  assert.deepEqual(patch.complete, true);
});

QUnit.test('do not extend a route-creating patch by backtracking', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  graph.addEdge(c, new UndirectedEdge(1), d);
  const patch = new Patch(graph, undefined);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [b, c, d]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [b, c, d]);
  assert.deepEqual(patch.complete, false);
});

QUnit.test('retract a route-creating patch', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  graph.addEdge(c, new UndirectedEdge(1), d);
  const patch = new Patch(graph, undefined);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [b, c, d]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(c);
  assert.deepEqual(patch.vertices, [b, c]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b, c, b]);
  assert.deepEqual(patch.complete, true);
});

QUnit.test('do not retract a route-creating patch on a repeated edit', (assert) => {
  const a = new Vertex('a');
  const b = new Vertex('b');
  const c = new Vertex('c');
  const d = new Vertex('d');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  graph.addVertex(b);
  graph.addVertex(c);
  graph.addVertex(d);
  graph.addEdge(a, new UndirectedEdge(1), b);
  graph.addEdge(b, new UndirectedEdge(1), c);
  graph.addEdge(a, new UndirectedEdge(1), c);
  graph.addEdge(c, new UndirectedEdge(1), d);
  const patch = new Patch(graph, undefined);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(b);
  assert.deepEqual(patch.vertices, [b]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [b, c, d]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(d);
  assert.deepEqual(patch.vertices, [b, c, d]);
  assert.deepEqual(patch.complete, false);
});

QUnit.test('cancel a route-creating patch on a repeated edit of its start when the patch has no edges', (assert) => {
  const a = new Vertex('a');
  const graph = new UndirectedGraph();
  graph.addVertex(a);
  const patch = new Patch(graph, undefined);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, [a]);
  assert.deepEqual(patch.complete, false);
  patch.editBy(a);
  assert.deepEqual(patch.vertices, []);
  assert.deepEqual(patch.complete, false);
});
